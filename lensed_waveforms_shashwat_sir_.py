# -*- coding: utf-8 -*-
"""lensed_waveforms_shashwat sir .ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gTjiFt9K15b9gYRKR-TMkk2JxnRDpxa3
"""

# this would not work because we dont have glow the library
import numpy as np
import sys, os
sys.path.insert(0, os.path.abspath('../../'))
from glow import freq_domain, time_domain_c, lenses

from pycbc.waveform import get_td_waveform, get_fd_waveform, utils
from pycbc.detector import Detector
from tqdm import tqdm
import warnings
from multiprocessing import Pool

warnings.filterwarnings("ignore")


G = 4.301 * 1e-9 # km^2 Mpc MSun^-1 s^-2

#for num_event in range(len(injection)):
def process_event(num_event):
	#print(num_event, injection[num_event, 0], injection[num_event, 1])
	hp, hc = get_td_waveform(approximant='IMRPhenomD', mass1=injection[num_event, 0],
							mass2=injection[num_event, 1], delta_t=1./2048, f_lower=50)
	hp_f, hc_f = hp.to_frequencyseries(), hc.to_frequencyseries()
	# make a strain unlensed data
	ht = Detector("H1").project_wave(hp, hc, injection[num_event, 2], injection[num_event, 3], injection[num_event, 4])

	# lens properties

	Mlz = injection[num_event, 5]

	y = injection[num_event, 6] # SIS has SL below 1 so choose any value between 1+ to 2

	Psi = lenses.Psi_SIS()

	# calculation settings
	p_prec_time = {
		'tmin': 1e-2,
		'tmax': 1e6,
		'Nt': 5000,
		'sampling': 'log',
		'interp_kind': 'linear'
	}

	p_prec = {
		'fmin': 1e-4,
		'fmax': 1e4,
		'FFT method': 'multigrid',
		'parallel': True,
		'N_below_discard': 3,
		'N_above_discard': 1,
		'N_keep': 1
	}

	p_phys = {'y':y,'Mlz':Mlz}

	# calculate amplification factor

	I = time_domain_c.It_SingleContour_C(Psi, p_phys, p_prec_time)
	Fw = freq_domain.Fw_WL(I, p_prec=p_prec)

	# calculate ws for the frequencies in the signal
	ws = 8 * np.pi * G * Mlz * hp_f.sample_frequencies.data
	Fws = Fw.eval_Fw(ws)

	# prepare lensed signal polarizations
	hp_fL = Fws * hp_f
	hc_fL = Fws * hc_f

	# make lensed polarizations time series
	hp_L, hc_L = hp_fL.to_timeseries(), hc_fL.to_timeseries()

	# lensed strain data
	ht_L = Detector("H1").project_wave(hp_L, hc_L, injection[num_event, 2], injection[num_event, 3], injection[num_event, 4])

	# plot strain
	f = utils.frequency_from_polarizations(hp.trim_zeros(), hc.trim_zeros())
	f_L = utils.frequency_from_polarizations(hp_L.trim_zeros(), hc_L.trim_zeros())

	ht_L = ht_L[(ht.sample_times>-.3) & (ht.sample_times<0.0)]/np.amax(np.abs(ht.data))
	ht = ht[(ht.sample_times>-.3) & (ht.sample_times<0.00)]/np.amax(np.abs(ht.data))


	f_L = f_L[(f.sample_times>-.3) & (f.sample_times<0.00)]/np.amax(np.abs(f.data))
	f = f[(f.sample_times>-.3) & (f.sample_times<0.00)]/np.amax(np.abs(f.data))

	np.save(f'./waveform/L{num_event}.npy', ht_L.data)
	np.save(f'./waveform/{num_event}.npy', ht.data)
	np.save(f'./freq-ser/L{num_event}.npy', f_L.data)
	np.save(f'./freq-ser/{num_event}.npy', f.data)

	del ht, ht_L, f, f_L

if __name__ == '__main__':
    injection = np.loadtxt('./injection.txt')
    num_processes = 8  # Adjust this based on your system and requirements

    with Pool(processes=num_processes) as pool:
        # Use the pool to parallelize event processing
        metadata = (list(tqdm(pool.imap(process_event, range(len(injection)), chunksize=1))))

    LABELS = np.empty(2 * len(injection))
    for num_event in range(0, len(LABELS), 2):
        LABELS[num_event] = 1
        LABELS[num_event] = 0
    np.save('./labels', LABELS)